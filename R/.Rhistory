?lm.ridg
?lm.ridge
??lm.ridge
install.packages("MASS")
library("MASS")
#生成具有相关性的3组数据模拟多重共线性
x1 <- rnorm(20)
x2 <- rnorm(20,mean=x1,sd=.01)
y <- rnorm(20,mean=3+x1+x2)
#普通LM回归的OLS系数
lm(y~x1+x2)$coef
#岭回归的OLS系数
lm.ridge(y~x1+x2,lambda=1)
#
fit <- lm.ridge(y~x1+x2,lambda=seq(0,50,by=0.1))
fit$GCV
plot(fit$GCV,seq(0,50,by=0.1))
plot(seq(0,50,by=0.1),fit$GCV)
lambda <- seq(0,50,by=0.1)
fit <- lm.ridge(y~x1+x2,lambda)
p <- ggplot(data=fit,aes(x=lambda,y=fit$GCV))
p+ggplot_point()
library("ggplot2")
lambda <- seq(0,50,by=0.1)
fit <- lm.ridge(y~x1+x2,lambda)
p <- ggplot(data=fit,aes(x=lambda,y=fit$GCV))
p+ggplot_point()
lambda <- seq(0,50,by=0.1)
fit <- lm.ridge(y~x1+x2,lambda=lambda)
p <- ggplot(data=fit,aes(x=lambda,y=fit$GCV))
p+ggplot_point()
lambda <- seq(0,50,by=0.1)
fit <- lm.ridge(y~x1+x2,lambda=seq(0,50,by=0.1))
p <- ggplot(data=fit,aes(x=lambda,y=fit$GCV))
p+ggplot_point()
x1 <- rnorm(20)
x2 <- rnorm(20,mean=x1,sd=.01)
y <- rnorm(20,mean=3+x1+x2)
lambda <- seq(0,50,by=0.1)
fit <- lm.ridge(y~x1+x2,lambda=seq(0,50,by=0.1))
p <- ggplot(data=fit,aes(x=lambda,y=fit$GCV))
p+ggplot_point()
lambda <- seq(0,50,by=0.1)
fit <- lm.ridge(y~x1+x2, lambda)
datafit <- as.data.frame(fit)
p <- ggplot(data=datafit,aes(x=lambda,y=fit$GCV))
p+ggplot_point()
lambda <- seq(0,50,by=0.1)
fit <- lm.ridge(y~x1+x2, lambda)
p <- ggplot(aes(x=lambda,y=fit$GCV))
p+ggplot_point()
lambda <- seq(0,50,by=0.1)
fit <- lm.ridge(y~x1+x2, lambda)
m <- data.frame(lambda,fit$GCV)
p <- ggplot(data=m,aes(x=lambda,y=GCV))
p+ggplot_point()
lambda <- seq(0,50,by=0.1)
fit <- lm.ridge(y~x1+x2, lambda)
m <- data.frame(lambda,fit$GCV)
p <- ggplot(data=m,aes(x=lambda,y=GCV))
p+ggplot_build()
lambda <- seq(0,50,by=0.1)
fit <- lm.ridge(y~x1+x2, lambda)
m <- data.frame(lambda,fit$GCV)
p <- ggplot(data=m,aes(x=lambda,y=GCV))
p+geom_point()
```
m <- data.frame(lambda,fit$GCV)
head(m)
lambda <- seq(0,50,by=0.1)
fit <- lm.ridge(y~x1+x2, lambda)
m <- data.frame(lambda,fit$GCV)
p <- ggplot(data=m,aes(x=lambda,y=fit.GCV))
p+geom_point()
lambda <- seq(0,50,by=0.1)
fit <- lm.ridge(y~x1+x2, seq(0,50,by=0.1))
lambda <- seq(0,50,by=0.1)
fit <- lm.ridge(y~x1+x2, lambda=1)
lambda <- seq(0,50,by=0.1)
fit <- lm.ridge(y~x1+x2, lambda=c(1,2))
fit <- lm.ridge(y~x1+x2, lambda=seq(0,50,by=0.1))
lambda <- seq(0,50,by=0.1)
fit <- lm.ridge(y~x1+x2, lambda=seq(0,50,by=0.1))
m <- data.frame(lambda,fit$GCV)
p <- ggplot(data=m,aes(x=lambda,y=fit.GCV))
p+geom_point()
library(car)
fit <- lm(weight ~ height, data=women)
qqPlot(fit,labels=row.names(women),id.method="identify", simulate=TRUE, main="Q-Q Plot")
install.packages("ccgarch")
library("MASS")
library("car")
load("longley.RData")
load("C:\\Users\\44180\\Documents\\R-in-SOE\\R\\R-class\\c9\\longley.RData")
lm.normal<-lm(y~.,data=longley)
summary(lm.normal)
vif(lm.normal)
mean(vif(lm.normal))
XX<-cor(longley[2:6])
kappa(XX,exact=T)
lm.r<-lm.ridge(y ~ ., longley)
plot(lm.ridge(y ~ ., longley, lambda = seq(0,0.1,0.001)))
plot(lm.ridge(y ~ ., longley, lambda = seq(0,0.1,0.001)))
windows(7,7)
plot(lm.ridge(y ~ ., longley, lambda = seq(0,0.1,0.001)))
#1 生成具有共线性的XY,;比较OLS和RIDGE系数
set.seed(1234)
x1 <- rnorm(20)
x2 <- rnorm(20,mean=x1,sd=.01)
y <- rnorm(20,mean=3+x1+x2)
lm(y~x1+x2)$coef
lm.ridge(y~x1+x2,lambda=1)
#2 生成具有共线性的数据
my.sample <- function (n=20) {
x <- rnorm(n)
x1 <- x + .1*rnorm(n)
x2 <- x + .1*rnorm(n)
y <- 0 + x1 - x2 + rnorm(n)
cbind(y, x1, x2)
}
n <- 500
r <- matrix(NA, nr=n, nc=3)
s <- matrix(NA, nr=n, nc=3)
corr <- matrix(NA, nr=n, nc=3)
for (i in 1:n) {
m <- my.sample()
corr[i,] <- cor(m[,2],m[,3])
r[i,] <- lm(m[,1]~m[,-1])$coef
s[i,2:3] <- lm.ridge(m[,1]~m[,-1], lambda=.1)$coef
s[i,1] <- mean(m[,1])
}
windows(7,7)
plot( density(r[,1]), xlim=c(-3,3),
main="Multicolinearity: high variance")
abline(v=0, lty=3)
lines( density(r[,2]), col="red" )
lines( density(s[,2]), col="red", lty=2 )
abline(v=1, col="red", lty=3)
lines( density(r[,3]), col="blue" )
lines( density(s[,3]), col="blue", lty=2 )
abline(v=-1, col="blue", lty=3) # We give the mean, to show that it is biased
r
head(r)
head(m)
evaluate.density <- function (d,x, eps=1e-6) {
density(d, from=x-eps, to=x+2*eps, n=4)$y[2]
}
x<-mean(r[,2]); points( x, evaluate.density(r[,2],x) )
x<-mean(s[,2]); points( x, evaluate.density(s[,2],x) )
x<-mean(r[,3]); points( x, evaluate.density(r[,3],x) )
x<-mean(s[,3]); points( x, evaluate.density(s[,3],x) )
evaluate.density <- function (d,x, eps=1e-6) {
density(d, from=x-eps, to=x+2*eps, n=4)$y[2]
}
x<-mean(r[,2]); points( x, evaluate.density(r[,2],x) )
library(ISLR)
install.packages("ISLR")
library(leaps)
names(Hitters)
dim(Hitters)
#去掉缺失值
sum(is.na(Hitters$Salary))
Hitters=na.omit(Hitters)
dim(Hitters)
sum(is.na(Hitters))
library(ISLR)
names(Hitters)
dim(Hitters)
#去掉缺失值
sum(is.na(Hitters$Salary))
Hitters=na.omit(Hitters)
dim(Hitters)
sum(is.na(Hitters))
regfit.full=regsubsets(Salary~.,data=Hitters,nvmax=19)
reg.summary=summary(regfit.full)
names(reg.summary)
reg.summary$adjr2
reg.summary$which
View(reg.summary$which)
reg.summary$adjr2
reg.summary$cp
par(mfrow=c(2,2))
plot(reg.summary$rss,xlab="Number of Variables",ylab="RSS",type="l")
plot(reg.summary$adjr2,xlab="Number of Variables",ylab="Adjusted RSq",type="l")
windows(7,7)
par(mfrow=c(2,2))
plot(reg.summary$rss,xlab="Number of Variables",ylab="RSS",type="l")
plot(reg.summary$adjr2,xlab="Number of Variables",ylab="Adjusted RSq",type="l")
which.max(reg.summary$adjr2)
points(11,reg.summary$adjr2[11], col="red",cex=2,pch=20)
plot(reg.summary$cp,xlab="Number of Variables",ylab="Cp",type='l')
which.min(reg.summary$cp)
points(10,reg.summary$cp[10],col="red",cex=2,pch=20)
which.min(reg.summary$bic)
plot(reg.summary$bic,xlab="Number of Variables",ylab="BIC",type='l')
points(6,reg.summary$bic[6],col="red",cex=2,pch=20)
par(mfrow=c(2,2))
plot(regfit.full,scale="r2")
plot(regfit.full,scale="adjr2")
plot(regfit.full,scale="Cp")
plot(regfit.full,scale="bic")
regfit.full
class(regfit.full)
coef(regfit.full,1)
cement<-data.frame( X1=c( 7, 1, 11, 11, 7, 11, 3, 1, 2, 21, 1, 11, 10),
X2=c(26, 29, 56, 31, 52, 55, 71, 31, 54, 47, 40, 66, 68),
X3=c( 6, 15, 8, 8, 6, 9, 17, 22, 18, 4, 23, 9, 8),
X4=c(60, 52, 20, 47, 33, 22, 6, 44, 22, 26, 34, 12, 12),
Y =c(78.5, 74.3, 104.3, 87.6, 95.9, 109.2, 102.7, 72.5, 93.1,115.9, 83.8, 113.3, 109.4)
)
lm.sol<-lm(Y ~ X1+X2+X3+X4, data=cement)
summary(lm.sol)
lm.step<-step(lm.sol)
summary(lm.step)
drop1(lm.step)
help(drop1)
lm.opt<-lm(Y ~ X1+X2, data=cement); summary(lm.opt)
x1=rnorm(100)
x2=rnorm(100)
x3=rnorm(100)
y=rnorm(100)
fm2 <- lm(y ~ x1 + x2)
fm3 <- update(fm2, . ~ . + x3) #add x3 to the fit model
smf3 <- update(fm3, I(y^2) ~ .)
fm2
fm3
